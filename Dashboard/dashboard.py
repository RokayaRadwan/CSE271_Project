# -*- coding: utf-8 -*-
"""dashboard

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dZMpcBYmlygBKwnEeUCvXdS0n2hhJ0vV
"""

import streamlit as st
import pandas as pd
import numpy as np
import joblib
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.linear_model import LogisticRegression, Lasso, LinearRegression
from sklearn.ensemble import RandomForestRegressor
from sklearn.neighbors import KNeighborsClassifier
from sklearn.preprocessing import PolynomialFeatures, StandardScaler
from sklearn.metrics import accuracy_score, confusion_matrix, roc_curve, auc, r2_score, mean_squared_error
from sklearn.model_selection import train_test_split

# --- Load Data ---
cls_df = pd.read_csv("mobile_addiction.csv")
cls_df.drop(columns=['Unnamed: 0'], inplace=True)
cls_df.rename(columns={'addicted': 'addiction_status'}, inplace=True)
cls_df['addiction_status'] = cls_df['addiction_status'].map({'addicted': 1, 'not addicted': 0})
cls_df['stress_risk'] = cls_df['stress_level'].apply(lambda x: 1 if x >= 6 else 0)

reg_df = pd.read_csv("mobile_usage_analysis.csv")

# --- Session State ---
if 'page' not in st.session_state:
    st.session_state.page = 'Home'

# --- Navigation ---
def show_home():
    st.title("üë©‚Äçüè´ Welcome Dr. Fatma!")
    st.subheader("üìò Data Science Methodologies Project")
    choice = st.radio("Choose a Prediction Technique:", ["Classification", "Regression"])
    if st.button("‚úÖ Choose"):
        st.session_state.page = choice

def back_button():
    if st.button("üîô Back to Home"):
        st.session_state.page = 'Home'

# --- Classification Page ---
def show_classification():
    st.title("üß† Classification Models")
    back_button()

    model_type = st.sidebar.radio("Choose Model", ["Logistic Regression", "KNN"])
    features = ['daily_screen_time', 'notifications', 'age']
    X = cls_df[features]
    y = cls_df['addiction_status'] if model_type == "Logistic Regression" else cls_df['stress_risk']

    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X)
    X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=42)

    if model_type == "Logistic Regression":
        model = LogisticRegression()
        description = "This model predicts addiction status using daily screen time, notifications, and age."
    else:
        model = KNeighborsClassifier(n_neighbors=5)
        description = "This model classifies stress risk based on mobile usage behavior."

    model.fit(X_train, y_train)
    y_pred = model.predict(X_test)
    acc = accuracy_score(y_test, y_pred)
    y_score = model.predict_proba(X_test)[:, 1]
    fpr, tpr, _ = roc_curve(y_test, y_score)
    roc_auc = auc(fpr, tpr)

    st.info(description)
    st.markdown(f"**Accuracy:** {acc:.2f}")
    st.markdown("**Confusion Matrix:**")
    fig, ax = plt.subplots(figsize=(3, 3))
    sns.heatmap(confusion_matrix(y_test, y_pred), annot=True, fmt='d', cmap='Blues', ax=ax)
    st.pyplot(fig)

    if st.checkbox("Show ROC Curve"):
        fig, ax = plt.subplots()
        ax.plot(fpr, tpr, label=f"ROC curve (AUC = {roc_auc:.2f})")
        ax.plot([0, 1], [0, 1], linestyle='--')
        ax.set_xlabel('False Positive Rate')
        ax.set_ylabel('True Positive Rate')
        ax.set_title('ROC Curve')
        ax.legend()
        st.pyplot(fig)

    st.subheader("üî¢ Input Features")
    user_input = [
        st.slider("Daily Screen Time", 1, 12, 6),
        st.slider("Notifications", 10, 150, 50),
        st.slider("Age", 10, 80, 30)
    ]
    if st.button("üîÆ Predict"):
        user_input_scaled = scaler.transform([user_input])
        result = model.predict(user_input_scaled)[0]
        if model_type == "Logistic Regression":
            label = "Addicted" if result == 1 else "Not Addicted"
        else:
            label = "High Stress Risk" if result == 1 else "Low Stress Risk"
        st.success(f"Prediction: {label}")

    st.subheader("üìä Data Visualizations")
    viz_type = st.selectbox("Choose Visualization:", ["Correlation with Targets", "Boxplot vs Target"])

    if viz_type == "Correlation with Targets":
        corr_matrix = cls_df.corr()
        corr_targets = corr_matrix[['addiction_status', 'stress_risk']].drop(['addiction_status', 'stress_risk', 'stress_level'])
        fig, ax = plt.subplots(figsize=(6, 6))
        sns.heatmap(corr_targets, annot=True, cmap='coolwarm', ax=ax)
        st.pyplot(fig)

    elif viz_type == "Boxplot vs Target":
        box_feat = st.selectbox("Choose Feature", features)
        target = 'addiction_status' if model_type == "Logistic Regression" else 'stress_risk'
        fig, ax = plt.subplots()
        sns.boxplot(x=cls_df[target], y=cls_df[box_feat], ax=ax)
        st.pyplot(fig)

# --- Regression Page ---
def show_regression():
    st.title("üìà Regression Models")
    back_button()

    model_type = st.sidebar.radio("Choose Model", ["Linear Regression", "Lasso Regression", "Polynomial Regression", "Random Forest Regression"])
    features = st.sidebar.multiselect("Select Features", ['daily_screen_time', 'night_usage'], default=['daily_screen_time'])
    X = reg_df[features]
    y = reg_df['stress_level']

    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    if model_type == "Lasso Regression":
        model = Lasso()
        model.fit(X_train, y_train)
        y_pred = model.predict(X_test)
    elif model_type == "Polynomial Regression":
        poly = PolynomialFeatures(degree=2)
        X_poly = poly.fit_transform(X)
        Xp_train, Xp_test, yp_train, yp_test = train_test_split(X_poly, y, test_size=0.2, random_state=42)
        model = LinearRegression().fit(Xp_train, yp_train)
        y_pred = model.predict(Xp_test)
    elif model_type == "Random Forest Regression":
        model = RandomForestRegressor(n_estimators=100, random_state=42)
        model.fit(X_train, y_train)
        y_pred = model.predict(X_test)
    else:
        model = LinearRegression()
        model.fit(X_train, y_train)
        y_pred = model.predict(X_test)

    st.subheader("üî¢ Input Features")
    input_values = []
    for feat in features:
        min_val = float(reg_df[feat].min())
        max_val = float(reg_df[feat].max())
        mean_val = float(reg_df[feat].mean())
        input_values.append(st.number_input(f"{feat}", min_value=min_val, max_value=max_val, value=mean_val, step=0.1))

    if st.button("üîÆ Predict"):
        input_df = pd.DataFrame([input_values], columns=features)
        if model_type == "Polynomial Regression":
            input_poly = poly.transform(input_df)
            prediction = model.predict(input_poly)[0]
        else:
            prediction = model.predict(input_df)[0]
        st.success(f"Predicted Stress Level: {prediction:.2f}")

    st.subheader("üìä Model Evaluation")
    if model_type == "Polynomial Regression":
        r2 = r2_score(yp_test, y_pred)
        rmse = mean_squared_error(yp_test, y_pred)**0.5
    else:
        r2 = r2_score(y_test, y_pred)
        rmse = mean_squared_error(y_test, y_pred)**0.5
    st.write(f"**R¬≤ Score:** {r2:.2f}")
    st.write(f"**RMSE:** {rmse:.2f}")

    st.subheader("üìä Correlation Heatmap")
    fig, ax = plt.subplots()
    sns.heatmap(reg_df[['daily_screen_time', 'night_usage', 'stress_level']].corr(), annot=True, cmap='coolwarm', ax=ax)
    st.pyplot(fig)

    st.subheader("üìä Scatterplot of Daily Screen Time vs Night Usage")
    fig, ax = plt.subplots()
    scatter = ax.scatter(reg_df['daily_screen_time'], reg_df['night_usage'], c=reg_df['stress_level'], cmap='viridis')
    ax.set_xlabel("Daily Screen Time")
    ax.set_ylabel("Night Usage")
    ax.set_title("Stress Level by Screen Time and Night Usage")
    legend1 = ax.legend(*scatter.legend_elements(), title="Stress Level")
    ax.add_artist(legend1)
    st.pyplot(fig)

# --- Routing ---
if st.session_state.page == 'Home':
    show_home()
elif st.session_state.page == 'Classification':
    show_classification()
elif st.session_state.page == 'Regression':
    show_regression()